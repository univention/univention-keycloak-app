#!/usr/bin/python3

import argparse

from keycloak import KeycloakAdmin
from univention.config_registry import ConfigRegistry
from univention.config_registry.frontend import ucr_update
from univention.udm import UDM

UDM_VERSION = 2

if __name__ == "__main__":
	# load UCR
	ucr = ConfigRegistry()
	ucr.load()
	hostname = ucr.get("hostname")
	domain = ucr.get("domainname")

	parser = argparse.ArgumentParser(description='Keycloak Autoconfig')

	pwdfile = "/etc/keycloak.secret"
	with open(pwdfile, 'r') as fd:
		pwd = fd.read().strip()

	# TODO: Remove parser and use variables ??
	parser.add_argument("--kc-admin-user", default="admin")
	parser.add_argument("--kc-admin-pass", default="a5dR5BFWvL6NtRgvhUfo")  # TODO:Change to pwd

	parser.add_argument("--kc-service-user", default="Administrator")  # TODO: Use dedicated user
	parser.add_argument("--kc-service-pass", default="univention")

	# realm config #
	parser.add_argument("--realm", default="ucs")
	parser.add_argument("--default-realm", default="master",
						help="The default realm and location of the admin user")

	# client config #
	parser.add_argument("--client-id-location", default="/univention/saml/metadata",
						help="SAML Metadata Location")
	parser.add_argument("--valid-redirect-urls", nargs='+', help='SAML Valid Redirect URLS')

	# user federation
	parser.add_argument("--ucs-user-dn", nargs="+", help="User DN to feed to LDAP Provider")
	parser.add_argument("--ucs-ldap-pass", help="User DN to feed to LDAP Provider")
	parser.add_argument("--ucs-bind-dn", help="Bind DN feed to LDAP Provider")
	parser.add_argument("--ucs-ldap-url", default="ldap://{}.{}:7389".format(hostname, domain), help="ldap://ip:port")

	# fallback for host/domainame #
	parser.add_argument("--hostname", help="Overwrite UCR sourced domain name")
	parser.add_argument("--domain-name", help="Overwrite UCR sourced hostname")

	# udm credentials
	parser.add_argument("--udm-admin-user", default="Administrator", help="User for UDM (admin)")
	parser.add_argument("--udm-admin-pass", default="univention",
						help="Credentials for UDM (admin)")

	# saml descriptor location #
	parser.add_argument("--saml-descriptor-location",
						default="/realms/ucs-test/protocol/saml/descriptor",
						help="Location of the saml descriptor with domain name")

	args = parser.parse_args()

	if args.domain_name:
		domain = args.domain_name
	if args.hostname:
		hostname = args.hostname

	ldap_hostdn = ucr.get("ldap/hostdn")
	user_dn = ldap_hostdn[ldap_hostdn.index(",dc="):][1:]
	bind_dn = "uid={udm_service_user},cn=users,{user_dn}".format(udm_service_user=args.kc_service_user, user_dn=user_dn)

	print("Using bind-dn: {}".format(bind_dn))

	if args.ucs_user_dn:
		user_dn = args.ucs_user_dn
	if args.ucs_bind_dn:
		bind_dn = args.ucs_bind_dn

	# derived composite vars #
	if hostname and not hostname == "unassigned-hostname":
		server_fdnq_with_subdomain = "https://keycloak.{}.{}".format(hostname, domain)
	else:
		server_fdnq_with_subdomain = "https://keycloak.{}".format(domain)

	# valid redirect uris #
	if args.valid_redirect_urls:
		valid_redirect_urls = args.valid_redirect_urls
	else:
		valid_redirect_urls = [server_fdnq_with_subdomain + "/univention/saml/"]

	# build kc admin session #
	kc_admin_auth_url = "{}".format(server_fdnq_with_subdomain)
	print("Using KC_URL: {}".format(kc_admin_auth_url))

	# log into default realm in case UCS realm doesn't exist yet #
	kc_admin = KeycloakAdmin(server_url=kc_admin_auth_url,
							username=args.kc_admin_user,
							password=args.kc_admin_pass,
							realm_name=args.realm,
							user_realm_name=args.default_realm,
							verify=True)

	# create ucs realm #
	realm_payload = {
		"id": args.realm,
		"realm": args.realm,
		"enabled": True
	}
	kc_admin.create_realm(payload=realm_payload, skip_exists=True)

	# create client #
	client_id = server_fdnq_with_subdomain + args.client_id_location
	print("Client ID: {}".format(client_id))

	# build urls #
	single_logout_service_url_post = server_fdnq_with_subdomain + "/univention/saml/slo/"
	single_logout_service_url_redirect = server_fdnq_with_subdomain + "/univention/saml/slo/"
	assertion_consumer_url_post = server_fdnq_with_subdomain + "/univention/saml/"
	kc_descriptor_url = server_fdnq_with_subdomain + args.saml_descriptor_location

	client_payload = {
		"clientId": client_id,
		"surrogateAuthRequired": False,
		"enabled": True,
		"alwaysDisplayInConsole": False,
		"clientAuthenticatorType": "client-secret",
		"redirectUris": valid_redirect_urls,
		"webOrigins": [],
		"notBefore": 0,
		"bearerOnly": False,
		"consentRequired": False,
		"standardFlowEnabled": True,
		"implicitFlowEnabled": False,
		"directAccessGrantsEnabled": True,
		"serviceAccountsEnabled": False,
		"publicClient": True,
		"frontchannelLogout": True,
		"protocol": "saml",
		"attributes": {
			"saml.multivalued.roles": "false",
			"saml.force.post.binding": "true",
			"oauth2.device.authorization.grant.enabled": "false",
			"backchannel.logout.revoke.offline.tokens": "false",
			"saml.server.signature.keyinfo.ext": "false",
			"use.refresh.tokens": "true",
			"oidc.ciba.grant.enabled": "false",
			"backchannel.logout.session.required": "true",
			"client_credentials.use_refresh_token": "false",
			"saml.signature.algorithm": "RSA_SHA256",
			"saml.client.signature": "false",
			"require.pushed.authorization.requests": "false",
			"id.token.as.detached.signature": "false",
			"saml.assertion.signature": "true",
			"saml_single_logout_service_url_post": single_logout_service_url_post,
			"saml.encrypt": "false",
			"saml_assertion_consumer_url_post": assertion_consumer_url_post,
			"saml.server.signature": "true",
			"exclude.session.state.from.auth.response": "false",
			"saml.artifact.binding.identifier": "JOtItQNol3ThXjMMWI3gcbW92sU=",
			"saml.artifact.binding": "false",
			"saml_single_logout_service_url_redirect": single_logout_service_url_redirect,
			"saml_force_name_id_format": "false",
			"tls.client.certificate.bound.access.tokens": "false",
			"acr.loa.map": "{}",
			"saml.authnstatement": "true",
			"display.on.consent.screen": "false",
			"saml.assertion.lifespan": "300",
			"token.response.type.bearer.lower-case": "false",
			"saml.onetimeuse.condition": "false",
			"saml_signature_canonicalization_method": "http://www.w3.org/2001/10/xml-exc-c14n#"
		},
		"authenticationFlowBindingOverrides": {},
		"fullScopeAllowed": True,
		"nodeReRegistrationTimeout": -1,
		"protocolMappers": [
			{
				"name": "userid_mapper",
				"protocol": "saml",
				"protocolMapper": "saml-user-attribute-mapper",
				"consentRequired": False,
				"config": {
					"attribute.nameformat": "URI Reference",
					"user.attribute": "uid",
					"friendly.name": "uid",
					"attribute.name": "urn:oid:0.9.2342.19200300.100.1.1"
				}
			}
		],
		"defaultClientScopes": [
			"role_list"
		],
		"optionalClientScopes": [],
		"access": {
			"view": True,
			"configure": True,
			"manage": True
		}
	}
	kc_admin.create_client(payload=client_payload, skip_exists=True)

	# connect to UDM #
	user_mod = UDM.credentials(args.udm_admin_user, args.udm_admin_pass).version(UDM_VERSION).get('users/user')

	# TODO: Not necessary in the future
	"""
	# check for existing user in UDM #
	ldap_search_results = list(user_mod.search(\"uid={}\".format(args.kc_service_user)))
	if ldap_search_results:
		dn = ldap_search_results.pop().dn
		cur_user_obj  = user_mod.get(dn)
		cur_user_obj.delete()
	
	# create service user in UDM #
	obj = user_mod.new()
	obj.props.username = args.kc_service_user
	obj.props.lastname = args.kc_service_user
	obj.props.password = args.kc_service_pass
	obj.save()
	"""

	# user federation ldap provider payload#
	ldap_component_payload = {
		"name": "ldap-provider",
		"providerId": "ldap",
		"providerType": "org.keycloak.storage.UserStorageProvider",
		"parentId": args.realm,
		"config": {
			"pagination": ["true"],
			"fullSyncPeriod": ["-1"],
			"startTls": ["false"],
			"connectionPooling": ["true"],
			"usersDn": [user_dn],
			"cachePolicy": ["DEFAULT"],
			"useKerberosForPasswordAuthentication": ["false"],
			"importEnabled": ["false"],
			"enabled": ["true"],
			"bindCredential": [args.kc_service_pass],
			"bindDn": [bind_dn],
			"changedSyncPeriod": ["-1"],
			"usernameLDAPAttribute": ["uid"],
			"vendor": ["other"],
			"uuidLDAPAttribute": ["entryUUID"],
			"allowKerberosAuthentication": ["false"],
			"connectionUrl": [args.ucs_ldap_url],
			"syncRegistrations": ["false"],
			"authType": ["simple"],
			"debug": ["false"],
			"searchScope": ["2"],
			"useTruststoreSpi": ["ldapsOnly"],
			"usePasswordModifyExtendedOp": ["true"],
			"trustEmail": ["false"],
			"priority": ["0"],
			"userObjectClasses": ["inetOrgPerson, organizationalPerson"],
			"rdnLDAPAttribute": ["uid"],
			"editMode": ["READ_ONLY"],
			"validatePasswordPolicy": ["false"],
			"batchSizeForSync": ["1000"]
		}
	}

	# find existing ldap provider & delete or just create if none exists #
	ldap_component_filter = {'name': 'ldap-provider', 'providerId': 'ldap'}
	ldap_component_list = kc_admin.get_components(ldap_component_filter)
	if not ldap_component_list:
		kc_admin.create_component(payload=ldap_component_payload)
		ldap_component_list = kc_admin.get_components(ldap_component_filter)
		print("LDAP User Federation Added: {}".format(args.ucs_ldap_url))

	ldap_component = ldap_component_list.pop()  # TODO: revise
	ldap_component_id = ldap_component.get("id")

	# TODO: do we need more mappers ?
	# User federation mapper (LDAP) #
	payload_ldap_uid_mapper = {
		"name": "uid",
		"parentId": ldap_component_id,
		"providerId": "user-attribute-ldap-mapper",
		"providerType": "org.keycloak.storage.ldap.mappers.LDAPStorageMapper",
		"config": {
			"ldap.attribute": [
				"uid"
			],
			"is.mandatory.in.ldap": [
				"false"
			],
			"read.only": [
				"true"
			],
			"user.model.attribute": [
				"uid"
			]
		}
	}

	# find existing uid->uid mapper or create if none exits #
	ldap_mapper_component_filter = {'name': 'uid', 'providerId': 'user-attribute-ldap-mapper'}
	ldap_mapper_component_list = kc_admin.get_components(ldap_mapper_component_filter)
	if not ldap_mapper_component_list:
		kc_admin.create_component(payload=payload_ldap_uid_mapper)

	# set umc/saml/idp-server #
	ucr_update(ucr, {"umc/saml/idp-server": kc_descriptor_url})
